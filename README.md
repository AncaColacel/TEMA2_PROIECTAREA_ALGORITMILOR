/* TEMA2 PROIECTAREA ALGORITMILOR ANCA-MARIA COLACEL 324CC /*

--- ORGANIZARE ---

Problema1.
Pentru aceasta problema am plecat de la sortarea topologica, varianta realizata cu algoritmul lui Kahn. Voi explica modul de gandire si ideile implementate. Am imbinat sortarea cu programarea dinamica. Am implementat functia topologicalSort. Initial imi declar variabilele necesare. Am nevoie de un vector dp, pe care il initializez cu 0. Valoarea maxima a acestui vector este rezultatul final. Incep prin a calcula vectorul de grade interioare pentru fiecare nod in parte (numarul de arce care intra in acel nod). Pentru a face acest lucru parcurg fiecare nod in parte si imi salvez temporar un vector cu lista acelui nod, adica nodurile in care se ajunge plecand din nodul luat in discutie si incrementez gradele pentru aceste noduri, copiii parintelui. Dupa asta, imi construiesc o coada in care voi introduce nodurile cu gradul 0. Incep sa extrag pe rand cate un nod din coada si sa fac prelucrari asupra lui. Ii parcurg lista de copii si verific daca tipul de date pentru cele 2 noduri este la fel, in caz afirmativ am o variabila cost care devine 0. Daca cele 2 noduri folosesc tipuri de date diferite, variabila cost este 1. Valoarea vectorului dp avand index acel nod va fi valoarea maxima intre dp-ul parintelui la care trebuie sa se adauge variabila cost obtinuta anterior si vechea valoare a dp-ului pentru acel copil (un nod poate fi vizitat de mai multe ori). In final numarul minim de context-switchuri este valoarea maximala a vectorului dp.
Sortarea topologica folosind algoritmul lui Kahn este preluata din laborator si de pe un site pe care il voi mentiona ca si referinta in bibliografie. Asupra acestui algoritm se realizeaza modificarile mentionate mai sus pentru a se ajunge la rezultatul final.
Partea de main si folosirea functiei MyScanner este preluata din tema 1. Imi citesc in variabilele corespunzatoare toate datele din fisiere, apoi apelez functia topologicalSort avand ca si parametri numarul de noduri din graf si tipul de date pentru fiecare task/nod.
Complexitatea pentru acest task este O(nr_noduri + nr_muchii) care vine din acele 2 for-uri imbricate din cadrul sortarii.

Problema2.
Pentru aceasta problema am utilizat algoritmul lui Tarjan pentru a gasi componentele tare conexe. M-am documentat pentru el pe un site pe care il voi mentiona in bibliografie si din laborator. Pentru algoritmul lui Tarjan am o functie principala si una ajutatoare care realizeaza dfs si alte adaugari. In functia principala initializez vectorii disc si low cu timpii specifici acestui algoritm. Imi declar de asemenea o stiva pentru a depozita nodurile si un vector de boolean pentru a retine daca un nod este sau nu vizitat. Se parcurge fiecare nod in parte si se aplica functia ajutatoare pe el. Folosesc o variabila Time pentru a sti timpul la care este vizitat fiecare nod, disc si low pentru acel nod primesc aceasta valoare apoi Time este incrementata. Se parcurg vecinii acestui nod, daca nu sunt vizitati se aplica recursiv functia de dfs pe ei iar la intoarcerea din recursivitate se actualizeaza valoarea low pentru nodul curent bazandu-se pe low-ul vecinului. Daca vecinul e deja vizitat se actualizeaza valoarea low a nodului folosind discul vecinului. In final se obtin componentele conexe verificand pentru care noduri valoarea disc este egala cu valoarea low si scotand din stiva pana la ajungerea la radacina componentei. Ideea pentru a rezolva aceasta problema se refera insa la reducerea grafului si obtinerea grafului condensat, astfel ca fiecare componenta conexa este redusa la un singur nod si se pastreaza doar muchiile dintre componente conexe nu si cele dintre nodurile din aceeasi componenta. Fac acest lucru in functia graf_condensat. Mai intai mi-am creat un hashmap in care pentru fiecare nod am retinut componenta conexa din care el face parte. Imi pastrez intr-o variabila componenta conexa din care face parte nodul cu gara speciala pentru ca voi avea nevoie mai tarziu. Apoi, pentru fiecare componenta conexa, pentru fiecare nod din ea si pentru fiecare vecin din componenta, verific daca vecinul face parte din aceeasi componenta conexa ca si nodul si ma folosesc de map pentru asta, apoi verific daca nu exista deja muchie spre acel vecin de la un alt nod din aceeasi componenta conexa si daca nu, adaug muchia in noul graf condensat. Dupa ce am format noul graf condensat, in main lucrez cu el. Mai intai, daca numarul de componente conexe este egal cu numarul de noduri inseamna ca graful condensat este identic cu graful initial deci pot lucra direct pe el, daca nu, lucrez pe graful nou, dar operatiile sunt la fel. Calculez gradele interne pentru fiecare nod si numarul de muchii pe care trebuie sa le adaug este egal cu numarul de noduri cu grad intern zero, deoarece daca intr-un nod nu intra nicio muchie atunci el are nevoie de muchie suplimentara pentru a se putea ajunge la el din gara speciala. De mentionat ca componenta cu gara speciala nu se pune la socoteala deoarece nu vreau sa ajung din gara in ea insasi.
Complexitatea pentru aceasta problema poate fi aproximata la O(C*N*M), unde C este numarul de componente conexe, N numarul de noduri pt fiecare componenta si M numarul de muchii care ies din acel nod, adica vecinii acelui nod.

Problema4.
Aceasta problema nu este rezolvata intr-un mod eficient, drept urmare obtin jumatate din punctaj. Am aplicat algoritmul dfs pentru fiecare "intrebare" in parte, folosind un for care parcurge vectorul de intrebari din fisierul de intrare. Algoritmul de dfs este realizat in varianta iterativa si m-am documentat pe un site pe care il voi lasa ca referinta in bibliografie. Modul de functionare este foarte simplu, functia primeste ca parametru nodul de start si numarul de muchii pe care le poate traversa. Bag acest nod intr-o stiva si intr-un while scot continutul stivei pana nu mai am elemente. Scot un element, incrementez un contor si verific daca valoarea lui este egala cu parametrul dat, parcurg vecinii nodului, ii marchez ca vizitati si ii bag in stiva. Daca parametrul cu numarul de muchii este prea mare si stiva se goleste returnez -1.
Complexitatea acestei probleme este O(Q*(nr_noduri + nr_muchii)) deoarece dfs-ul este parcurs de Q ori, unde Q este numarul intrebarilor.

--- Bibliografie ---
https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/ (algoritm folosit la problema 1)
https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/ (algortim folosit la problema 2)
https://www.geeksforgeeks.org/iterative-depth-first-traversal/ (algoritm folosit pentru problema 4)
